# 第四章异步编程
## 函数式编程
### 高阶函数
高阶函数就是可以把函数作为参数，或是将函数作为返回值的函数，如下的代码
```
function foo(x) {
  return function () {
    return x;
  }
}
```
除了通常意义的函数调用返回外，还形成了一种后续传递风格的结果接收方式，而非单一的返回值形式。后续传递风格的程序编写将函数的业务重点从返回值转移到了回调函数中。
```
function foo(x, bar) {
  return bar(x);
}
```
一个更经典的例子便是数组的sort()方法，它是一个货真价实的高阶函数，可以接受一个方法作为参数参与运算排序。见sort.js

通过sort()方法的参数，可以决定不同的排序方式，从这里可以看出高阶函数的灵活性。结合Node提供的最基本的事件模块可以看到，事件处理方式正是基于高阶函数的特性来完成的。在自定义事件实例中，通过为相同事件注册不同的回调函数，可以很灵活地处理业务逻辑。
```
var emitter = new events.EventEmitter();
emitter.on('event_foo', function () {
  // TODO
})
```
书中时常提到事件可以十分方便地进行复杂业务逻辑的解耦，它其实受益于高阶函数。

高阶函数在JavaScript中比比皆是，很多迭代器方法(forEach()/map()/reduce()/reduceRight()/filter()/every()/some())十分典型。
### 偏函数用法
偏函数用法是指创建一个调用另外一个部分————参数或变量已经预置的函数————的函数的用法。可见 typeCheck.js

在JavaScript中进行类型判断时，我们通常会进行类似typeCheck.js的方法定义。这段代码固然不复杂，只有两个函数的定义，但是里面存在的问题是我们需要重复去定义一些相似的函数，如果有更多的isXXX()，就会出现更多的冗余代码。为了解决重复定义的问题，我们引入一个新函数，这个新函数可以如工厂一样批量创建一些类似的函数。见 typeCheck2.js,我们通过isType()函数预先指定type的值，然后返回一个新的函数。

可以看出，引入isType()函数后，创建isString()、isFunction()函数就变得简单多了。这种通过指定部分参数来产生一个新的定制函数的形式就是偏函数。
## 异步编程的优势与难点
### 1. 难点1：异常处理
过去我们处理异常时，通常使用类Java的try/catch/final语句块进行异常捕获，示例代码如下：
```
try {
  JSON.parse(json);
} cache (e) {
  // TODO
}
```
但是这对于异步编程而言并不一定适用。第三章提过，异步I/O的实现主要包含两个阶段：提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求后立即返回，因为异常不一定发生在这个阶段，try/catch的功效在此处不会发挥任何效果。异步方法的定义如下所示：
```
var async = function(callback) {
  process.nextTick(callback);
}
```
调用async()方法后，callback被存放起来，直到下一个事件循环才会取出来执行。尝试对异步方法进行try/catch操作只会捕获当次事件循环内的异常，对Callback执行时抛出的异常将无能为力，示例代码如下
```
try{
  async(callback)
} cache(e) {
  // TODO
}
```
Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出：
```
async(function(error, results) {
  // TODO
});
```
在我们自行编写的异步方法上，也需要去遵循这样一些原则：

原则一：必须执行调用者传入的回调函数；

原则二：正确传递回异常供调用者判断。

示例代码如下：
```
var async = function (callback) {
  process.nextTick(function(error) {
    var results = someting;
    if(error) {
      return callback(error)
    }
    callback(null, results);
  })
}
```
在异步方法的编写中，另一个容易犯的错误是对用户传递的回调函数进行异常捕获，示例代码如下：
```
try {
  req.body = JSON.parse(buf, options.reviver);
  callback();
} cache(e) {
  err.body = buf;
  err.status = 400;
  callback(e);
}
```
上述的代码意图是捕获JSON.parse()中可能出现的异常，但是却不小心包含了用户传递的回调函数。这意味着如果回调函数中有异常抛出，将会进入catch()代码块中执行，于是回调函数将会被执行两次。这显然不是预期的结果，可能导致业务的混乱，正确的捕获应为：
```
try {
  req.body = JSON.parse(buf, options.reviver);
} catch(e) {
  err.body = buf;
  err.status = 400;
  return callback(e);
}
callback();
```
在编写异步方法时，只要将异常正确地传递给用户的回调方法即可，无须过多处理。
### 2. 难点2：函数嵌套过深
对于Node而言，事务中存在多个异步调用的场景比比皆是。对于这些场景，由于两次操作存在依赖关系，函数嵌套的行为也许情有可原。那么，在网页焕然的过程中，通常需要数据、模板、资源文件，这三者相互之间并不依赖，但最终渲染结果中三者缺一不可。如果采用默认的异步方法调用，就会出现回调地狱的情况。

这在结果的保证上是没有问题的，问题在于这并没有利用好异步I/O带来的并行优势。这是异步编程的典型问题i。
### 3. 难点3：阻塞代码
对于刚开始JavaScript开发不久的人来说，发现竟然没有sleep()这样的线程沉睡功能，唯独能用于延时操作的就只有setInterval和setTimeout这两个函数。但是让人惊讶的是，这两个函数并不能阻塞后续代码的持续执行。所以有很多开发者会写出下面的代码
```
var start = new Date();
while(new Date() - start > 1000) {
  // TODO
}
// 阻塞代码
```
但是事实上是糟糕的，这段代码会持续占用CPU进行判断，与真正的线程沉睡相距甚远，完全破坏了事件循环的调度。由于Node单线程的原因，CPU资源全都会用于为这段代码服务，导致任何请求都回得不到响应。

所以遇到这种问题还是使用setTimeout的好。
### 4. 难点4：多线程编程
我们在谈论JavaScript的时候，通常谈的是单一线程上执行的代码，这在浏览器中指的是JavaScript执行线程与UI渲染共用的一个线程；在Node中只是没有UI渲染的部分，模型基本相同。对于服务器端而言，如果服务器是多核CPU，单个Node进程实质上是没有充分利用多核CPU的。随着现如今业务的复杂化，对于多核CPU利用的要求也越来越高。浏览器提出了Web Workers，它通过将JavaScript执行与UI渲染分离，可以很好地利用多核CPU为大量计算服务。同时前端Web Workers也是一个利用消息机制合理使用多核CPU的理想模型。

Web Workers能解决利用CPU和减少阻塞UI渲染，但是不能解决UI渲染的效率问题。Node借鉴了这个模式，child_process是其基础API，cluster模块是更深层次的应用。借助Web Workers的模式，开发人员要更多地去面临跨线程的编程，这对于以往的JavaScript编程经验是较少考虑的。
### 5. 难点5：异步转同步
Node提供了绝大部分的异步API和少量的同步API，偶尔出现的同步需求将会因为没有同步API让开发者突然无所适从。目前，Node 中试图同步式编程，但并不能得到原生支持，需要借助库或者编译等手段来实现。但对于异步调用，通过良好的流程控制，还是能够将逻辑梳理成顺序式的形式。
## 异步编程解决方案