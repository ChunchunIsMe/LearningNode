# 第二章模块机制
## CommonJS
### CommonJS的规范
1. 模块引用
```
const math = require('math');
```
CommonJS中使用require来导入模块
2. 模块导出
```
export.add = function () {
    return argument.reduce((total, item) => (total + item), 0);
}
```
在模块中还存在一个module对象，它表示模块自身，而exports是module的属性。在Node中一个文件就是一个模块，将方法挂载在 exports对象上作为属性即可定义导出的方式。
3. 模块标识
模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径。它可以没有文件名后缀.js。并且CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染。
### Node的模块实现
在Node中引入模块，需要经历如下3个步骤
1. 路径分析
2. 文件定位
3. 编译执行

在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

- 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以他的加载速度是最快的
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢
#### 优先从缓存加载
与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。

不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查咸鱼文件模块的缓存检查。
#### 路径分析和文件定位
因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异
1. 模块标识符分析

模块标识符主要分为核心模块（如http、fs、path等）、相对路径模块（.或..开始的模块）、绝对路径模块（/开始的模块）、非路径形式的文件模块（如自定义的connect）

- 核心模块

优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译成为了二进制代码，其加载过程最快。

如果想要加载一个和核心模块名字一样的自定义模块，那是不会成功的，因为核心模块的优先级是高于文件模块的。

- 路径形式的文件模块

在分析文件模块时，require()方法会将路径转化为真实路径，并以真实路径为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。

因为文件模块给Node指明了确切的文件位置，所以在查找的过程中可以节省大量时间，其加载速度慢于核心模块。

- 自定义模块

自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找也是最费时的，也是所有方式中最慢的一种。

我们可以进行尝试一下

模块路径这个概念指的是在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的规则，我们可以手动尝试一番（具体代码查看path.js）

运行path.js然后你发现打印出来一个路径数组

所以可以看出，模块路径的生成规则

当前文件目录下的node_module

父级目录下的node_module

父级的父级目录下的node_module

沿路径向上逐级递归，直到根目录下的node_module

在加载的过程中，node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找的耗时会越多，这是自定义模块加载速度最慢的原因。

2. 文件定位
从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了了再次加载模块时的效率

但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。

- 文件扩展名分析

require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按照.js、.json、.node的次序补足扩展名，依次尝试。

在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。

- 目录分析和包

在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件啊，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时会经常出现，此时Node会将目录当做一个包来处理。

在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json(CommondJs包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件缺少扩展名，将会进入扩展名分析的步骤。

如果main属性指定的文件名错误，或者没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。

如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有找到目标文件，则会抛出查找失败的异常。
#### 模块编译
在Node中，每个文件模块都是一个对象，他的定义见module.js

编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有不同，具体如下所示。

- .js文件。通过fs模块同步读取文件后编译执行。
- .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加在最后编译生成的文件。
- .json文件。通过fs模块同步读取文件之后，用JSON.parse()解析返回结果。
- 其余扩展名文件。它们都被当做.js文件载入。

每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。

根据不同的文件扩展名，Node会调用不同的读取方式，如.json文件的调用方式见read-json.js

其中，Module._extensions会被赋值给require()的extensions属性，所以通过在代码中访问require.extensions可以知道系统中已有的扩展加载方式。可以运行see-load.js

可以得到执行结果`{ '.js': [Function], '.json': [Function], '.node': [Function] }`

如果想对自定义扩展名进行特殊的加载，可以通过类似`require.extensions['.ext']`的方式实现。早期的CoffeeScript文件就是通过`require.extensions['.coffee']`扩展的方式来实现加载的。但是从v0.10.6版本开始，官方不鼓励通过这种方式来自定义扩展名的加载，而是期望先将其他语言转换为js文件后再加载。

1. JavaScript模块的编译
在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname) {\n, 在尾部添加了\n});。

一个正常的JavaScript文件会被包装成area.js的样子，这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的runInThisContext()方法执行（类似于eval，只是具有明确上下文，不污染全局），返回一个具体的function对象。最后将让当前模块对象的exports属性、require()方法、module(模块对象自身),以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。

这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。

此外，许多初学者都曾经纠结过为何存在exports的情况下，还存在module.exports。理想情况下，只要给exports赋值即可。
```
exports = function () {
    // my class
}
```
但是上面的代码通常就会得到一个失败的结果。通过area.js的代码我们可以知道，exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但不能改变作用域外的值。所以结论是如果你要给exports直接赋值请使用module.exports。如果你只是想给exports添加属性，则只需要使用exports即可。

2. C/C++模块的编译

Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和*nix平台下分别有不同的实现， 通过libuv兼容层进行了封装。

实际上，.node的模块文件不需要编译，因为他是C/C++编译之后编译生成的，所以这里只有加载和执行的过程。